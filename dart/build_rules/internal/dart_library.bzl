load(
    ":common.bzl",
    "api_summary_extension",
    "merged_lib_name",
    "has_dart_sources",
    "make_dart_context",
    "relative_path",
)
# TODO: Migrate both of these to an aspect? This would eliminate the
# ddc/analyzer dependency for targets which don't actually need them.
load(":analyze.bzl", "summary_action")
load(":ddc.bzl", "ddc_action")

def _path_under_package(label, src_file):
  """Finds the path beneath a Dart package to a File.

  For example for the target //path/to/package:library and the file
  path/to/package/lib/file.dart returns `lib/file.dart`.
  """
  path = src_file.short_path
  # Files in external repositories have paths like `../repository_name/lib/file`
  if path.startswith("../"):
    # Normalize the ../directory/
    second_slash = path.find("/", 4)
    path = path[second_slash + 1:]
  # Packages that aren't at the root level have paths like
  # `path/to/package/lib/file`
  if label.package:
    path = path[len(label.package) + 1:]
  return path

def dart_library_impl(ctx):
  """Implements the dart_library() rule."""

  ddc_output = ctx.outputs.ddc_output if ctx.attr.enable_ddc else None
  source_map_output = ctx.outputs.ddc_sourcemap if ctx.attr.enable_ddc else None
  strong_summary = ctx.outputs.strong_summary
  _has_dart_sources = has_dart_sources(ctx.files.srcs)

  link_command = []
  final_srcs = []
  linked_srcs = []
  for src in ctx.files.srcs:
    path = _path_under_package(ctx.label, src)
    # Since we might merge with a target that has generated source, link files
    # that might be imported to a new directory which is always under bazel-bin
    if path.startswith("lib/"):
      path = path.replace("lib/", merged_lib_name, 1)
      linked_file = ctx.new_file(path)
      final_srcs.append(linked_file)
      linked_srcs.append(linked_file)
      link_target = relative_path(linked_file.dirname, src.path)
      link_command.append("ln -s %s %s" % (link_target, linked_file.path))
    else:
      final_srcs.append(src)

  if len(link_command) > 0:
    ctx.action(
        command = "\n".join(link_command),
        inputs = ctx.files.srcs,
        outputs = linked_srcs,
    )

  dart_ctx = make_dart_context(
      ctx,
      srcs = final_srcs,
      data = ctx.files.data,
      deps = ctx.attr.deps,
      pub_pkg_name = ctx.attr.pub_pkg_name,
      strong_summary = strong_summary,
  )

  if not _has_dart_sources:
    ctx.file_action(
        output=strong_summary,
        content=("// empty summary, package %s has no dart sources" %
                 ctx.label.name))
  else:
    summary_action(ctx, dart_ctx)

  if ctx.attr.enable_ddc:
    if not _has_dart_sources:
      ctx.file_action(
          output=ddc_output,
          content=("// intentionally empty: package %s has no dart sources" %
                   ctx.label.name))
      ctx.file_action(
          output=source_map_output,
          content=("// intentionally empty: package %s has no dart sources" %
                   ctx.label.name))
    else:
      ddc_action(ctx, dart_ctx, ddc_output, source_map_output)

  return struct(
      dart=dart_ctx,
      ddc=struct(
        enabled=ctx.attr.enable_ddc,
        output=ddc_output,
        sourcemap=source_map_output,
      ),
  )

def dart_library_outputs(enable_ddc):
  """Returns the outputs of a Dart library rule.

  Dart library targets emit the following outputs:

  * name.api.ds: the strong-mode summary from dart analyzer (API only), if specified.
  * name.js:     the js generated by DDC if enabled
  * name.js.map: the source map generated by DDC if enabled

  Returns:
    a dict of types of outputs to their respective file suffixes
  """
  outs = {
    "strong_summary": "%{name}." + api_summary_extension,
  }

  if enable_ddc:
    outs += {
      "ddc_output": "%{name}.js",
      "ddc_sourcemap": "%{name}.js.map",
    }

  return outs
